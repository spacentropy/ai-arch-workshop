# Мотивация, задача
Хотим дать клиентам возможность поделиться собранной корзиной. Это может быть полезно, когда у человека возникли проблемы с оплатой или у друга есть бонусные баллы, которые сейчас хочется потратить. В таких случаях второму человеку приходится заново собирать корзину, что раздражает и отнимает время*.* 
Кроме того, фича открывает больше пространство для творчества CVM. Идей куда это развивать накинули много, но для начала хочется реализовать базовый сценарий и посмотреть на метрики.
Метрики
-кол-во пошареных корзин
-рост среднего чека у тех, кто открывает ссылки
-рост CR в заказ у тех, кто открывает ссылки
В общих чертах механика выглядит так:
Нажимаем кнопку "Поделиться корзиной". Бэк приложения сохраняет состояние корзины (список товаров) и генерит deeplink в который зашит id сохраненной корзины. Планируем завернуть deeplink в openlink (appsflyer), чтобы он вел магазины приложений, если они не установлены.
Deeplink можно отправить на другое устройство через стандартный компонент (например скинуть в Telegram). После его открытия на другом устройстве будет совершен переход в приложение, где мы отобразим шторку с превью и кнопку "Добавить к моей корзине". По нажатию на кнопку, бэк найдет сохраненную корзину и переложит ее товары в текущую.
В шторке с превью мы подсветим каких товаров нет в текущем меню (ведь кто-то может открыть ссылку в другом городе). Более сложные проверки делать не будем, для этого есть сама корзина и расчет заказа.
# Описание
Новые эндпоинты, которые добавляем в мапи
### Для клиента, который шарит корзину
#### POST /api/v1/cart/share/createLink
Сохраняем продукты из текущей корзины (только id продуктов + id топпингов), а также id пиццерии (чтобы потом найти ее меню, если потребуется) в отдельную сущность SharedCart. Она будет лежать в монге с ttl 2 недели.
Возвращаем приложению link, собранный по шаблону `URL/FbUr?deep_link_value=dodo://cartShare?id=id`, в дальнейшем завернем его в openlink.
На энпоинт стоит ограничение 30 запросов в день для уникального deviceId
```JSON
workflowid приходит во всех запросах к беку
```
```JSON
{
  "link": "String",
  "sharedCartId": "String",
}
```
### Для клиента, который откроет ссылку
### GET /api/v1/cart/share/preview?sharedCartId=string
Отдаем приложению список товаров, которые есть в SharedCart, чтобы показать шторку с превью. Бэк найдет пошареную корзину по ид, возьмет оттуда список товаров, затем соберет для них вью модели с помощью текущего меню. В том случае, если у отправляющей стороны было другое меню, достанем его тоже (для этого в SharedCart есть ид пиццерии), чтобы найти недостающие товары.
```JSON
{
  "items": [
    {
      "id": "String",
      "count": "Int",
      "order": "Int",
      "errorCode": "Int",
      "price": "Double",
      "name": "String",
      "image": ImageDtoV5, 
      "description": "String?"
    }
  ],
  "errorCode": "Int?"
}
```
### POST /api/v1/cart/share/apply
После нажатия на кнопку "Добавить к моей корзине", бэк возьмет ид пошареной корзины, извлечет оттуда товары и попытается каждый из них добавить в текущую корзину. При добавлении отработают все стандартные правила добавления товара в корзину (как будто их по очереди добавляла мобилка по обычному флоу)
```JSON
{
  "sharedCartId": "String",
  "replace": "Boolean",
  "workflowId": "String"
}
```